const.RPO_RATE_WIDTH=8
const.TRANSACTION_HASH_MEMORY_INDEX=10
const.UNKNOWN_UTXO_HASH=100

#! Performs a mod b => q * b + r
#! Stack goes from [b, a] to remainder and quotient [r, q]
proc.divmod
    push.0
    movdn.2
    dup.1 dup.1
    gte
    while.true
        movup.2 add.1 movdn.2 # increment quotient
        dup
        movdn.2
        sub
        swap
        dup.1 dup.1
        gte
    end
    drop
end

#! Compute RPO hash of a UTXO which is composed of owner (4 words) and value (1 word)
proc.utxo_hash
    # Because it's not a multiple of 8, we pad with 1,0,0,0 and append 1,0,0 to value, ref: ElementHasher
    push.1.0.0.0
    adv_push.5
    push.1.0.0
    hperm
    dropw swapw dropw # Isolate hash because final output is [Word, Hash, Word].
end

#! Compute the RPO hash of elements from a range of addresses in memory.
#! The input stack is `[n, start, ...]` and the output stack is `[HASH, ...]`.
#! `n` is the number of elements to hash, `start` is the memory address to start at.
#! It is assumed the elements are contiguous in memory. `n` does not need to be a multiple
#! of 4 (i.e. the data does not need to be in whole words), but 4 elements will be
#! taken from each memory address. For example, with input `[6, 0x02, ...]` the whole
#! word will be taken from address `0x02` and the first two elements of the word at
#! address `0x03` will also be included in the hash.
proc.range_hash
    push.RPO_RATE_WIDTH
    u32checked_divmod
    dup
    movdn.3 # put the extra copy of `n % RPO_RATE_WIDTH` away, we'll need it later
    eq.0
    if.true
        # If `n % RPO_RATE_WIDTH == 0` then state starts as all zeros.
        push.0
    else
        # Otherwise the state begins with a 1
        push.1
    end
    push.0.0.0
    push.0.0.0.0.0.0.0.0
    # The element 12 items down the stack now is `n / RPO_RATE_WIDTH`, which
    # is the number of full states we can fill before needed to handle the remainder.
    movup.12
    dup
    push.0 gt
    while.true
        sub.1 # subtract 1 from the number of whole cycles counter
        movdn.12 # move the counter down below the current hasher state
        dropw dropw # drop the words that are going to be replaced
        movup.5 # pull up the memory address we are supposed to load from
        dup
        padw movup.4 mem_loadw
        movup.4
        add.1
        dup
        padw movup.4 mem_loadw
        movup.4
        add.1
        movdn.13 # put the memory counter away
        hperm # do the hashing
        movup.12 # bring the cycles counter back
        dup
        push.0 gt
    end
    # Loop over -- no more full cycles left
    assertz # the top of the stack should be 0 if everything has worked so far
    movup.13 # bring back the `n % RPO_RATE_WIDTH` value from earlier.
    dup
    eq.0
    if.true
        # the last full cycle was the end (no remainder), so just stack cleanup
        drop # drop the `n % RPO_RATE_WIDTH` value
        dropw # drop the last word of the state
        swapw # we're going to keep the second word of the state
        dropw # drop the first word of the state
        movup.4 # pull up the memory counter and drop it
        drop
    else
        # still 1 more hperm to do.
        movdn.13 # put away the `n % RPO_RATE_WIDTH` value
        dropw dropw # drop the words we're going to replace
        movup.4 # bring up the memory counter
        dup
        padw movup.4 mem_loadw
        movup.4
        add.1
        movup.9 # bring back up `n % RPO_RATE_WIDTH` value
        dup
        push.4 gt
        if.true
            # if `n % RPO_RATE_WIDTH > 4` then we need to load up the next word too
            sub.4
            movdn.9
            padw movup.4 mem_loadw # it's ok to consume our memory counter, we don't need it anymore
            movup.12
            # The number on top of the stack is in the range [1, 3]
            # it tells us how many elements we had to read from the word
            # we just read. The element after that is set to 1 and the reset to 0.
            push.4 swap sub
            # Now the number on top of the stack represents how many elements
            # we need to modify (but it is still in the range [1, 3]).
            dup
            eq.1
            if.true
                # Need to modify only the last element
                drop # drop the bookkeeping value
                drop # drop the last element from the word we read from memory
                push.1
            else
                eq.2 # it's ok to consume our bookkeeping value, we don't need it anymore
                if.true
                # Need to modify two elements
                drop drop # drop the elements to modify
                push.1.0
                else
                # Must need to modify three elements
                drop drop drop
                push.1.0.0
                end
            end
        else
            # if `n % RPO_RATE_WIDTH <= 4` then we do not need to load another word
            swap drop # drop memory counter (which was the next element on the stack)
            # The number on top of the stack is in the range [1, 4]. It is how many elements
            # to use from the last word we read from memory.
            push.4 swap sub
            # Now the number on top of the stack represents how many elements
            # we need to modify and it is in the range [0, 3].
            dup
            eq.0
            if.true
                # We used the whole prior word, so just drop the bookkeeping value and
                # fill in the rest of the state
                drop
                push.1.0.0.0
            else
                dup
                eq.1
                if.true
                    drop # drop bookkeeping value
                    drop # drop value to replace
                    push.1
                else
                    eq.2 # it's ok to consume the bookkeeping value now
                    if.true
                        drop drop
                        push.1.0
                    else
                        # must be 3 values to replace
                        drop drop drop
                        push.1.0.0
                    end
                end
                # push on the rest of the state
                push.0.0.0.0
            end
        end
        hperm # do the last hashing
        # stack cleanup
        dropw swapw dropw
    end
end

#! Search for the transaction hash index and push on to the stack. If not found, error out
#! Note: Assumes the stack has the Merkle root at the top and memory has the transaction input hash
proc.merkle_index
    # Iterate over all the Merkle tree leaves starting from index 0
    push.0 mem_store.0
    repeat.8
        mem_load.0
        push.3

        mtree_get
        padw mem_loadw.TRANSACTION_HASH_MEMORY_INDEX
        eqw
        if.true
            mem_load.0
            # Index 1,2... when found and 0 for not found
            add.1
            mem_store.1
        end
        dropw dropw

        # Increment the current index
        mem_load.0
        add.1
        mem_store.0
    end

    # Error out if index is not found and adjust index to start from 0 again
    mem_load.1
    eq.0
    assertz.err=UNKNOWN_UTXO_HASH
    mem_load.1
    sub.1
end

#! Operand stack starts as [tx_size, TX_HASH, STATE_ROOT], where
#! `tx_size` is the number of elements in the serialized transaction.
#! The advice stack contains the transaction serialized as field elements.
#! Execution proceeds as follows:
#!   1. Verify `hash(advice_stack) == TX_HASH`.
#!   2. Verify transaction input UTXO is in the state merkle tree.
#!   3. Verify the signature over the transaction is valid. (TODO)
#!   4. Verify the value of the output UTXOs is less than or equal to the input UTXO value. (TODO)
#!   5. Pop the input UTXO out of the state merkle tree. (TODO)
#!   6. Push the output UTXOs into the state merkle tree. (TODO)
#!   7. Finish with the updated state root in the operand stack. (TODO)
proc.main
  # 1.a load the advice stack into memory
  dup # make a copy of the number of elements (we'll need it later)
  push.TRANSACTION_HASH_MEMORY_INDEX # initialize memory counter
  swap # bring elements counter to the top
  dup
  push.4 gte # check we can store a whole word
  while.true
    swap # bring memory counter to the top
    padw
    adv_loadw # load first word of advice stack
    movup.4 # bring the memory counter to the top
    dup movdn.5 # copy the counter and push it down
    mem_storew # store the advice word in memory
    dropw # drop the word we stored off the operand stack
    add.1 # increment the memory counter
    swap # bring the elements counter back up
    sub.4 # subtract 4 since we just stored 4 elements
    dup push.4 gte # check if there is a whole word left
  end
  dup push.0 gt # check if we need to store a partial word
  if.true
    swap # bring memory counter to the top
    padw
    adv_loadw # load first word of advice stack
    movup.4 # bring the memory counter to the top
    mem_storew # store the advice word in memory (consuming the memory counter)
    dropw # drop the word we stored off the operand stack
    drop # drop the elements counter
  else
    drop drop # drop the memory counter and elements counter
  end
  # 1.b compute the hash of the data in memory
  push.TRANSACTION_HASH_MEMORY_INDEX # bring back the starting memory address
  swap # bring the number of elements to the top
  exec.range_hash
  # 1.c check the hash matches
  assert_eqw

  # 2. check the input is in the state
  exec.merkle_index

  # TODO: steps 3 - 7
end

begin
    exec.main
end
